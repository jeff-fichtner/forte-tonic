/**
 * Google Apps Script Migration DEV001 (Updated): Realistic Fake Data Generation
 *
 * DEVELOPMENT MIGRATION - Use only in development/testing environments!
 *
 * This script replaces all the letter/number fake data (like "Parent 1", "Teacher 11",
 * "A4 K4-1") with realistic fake names and ensures all relational IDs are properly updated.
 * 
 * UPDATED for UUID structure post-migrations:
 * - Works with UUID primary keys (generated by Migration003/004)
 * - Handles both legacy IDs and new UUID structure
 * - Updates foreign key relationships correctly
 * - Preserves LegacyId columns when present
 *
 * Features:
 * - Uses realistic fake names (inspired by faker libraries)
 * - Maintains all relational integrity (parent1Id, parent2Id, instructorId, etc.)
 * - Preserves class schedules and room assignments
 * - Creates consistent email addresses based on names
 * - Generates realistic phone numbers
 * - Works with both pre and post-UUID migration structures
 *
 * To use:
 * 1. Open your Google Sheets document (DEVELOPMENT ONLY!)
 * 2. Go to Extensions > Apps Script
 * 3. Copy this entire file content into a new .gs file
 * 4. Configure spreadsheet ID in Config.js (loaded automatically)
 * 5. Run the main function: runUpdatedRealisticFakeDataMigration()
 */

/**
 * Safe execution function with environment validation
 * This is the recommended entry point - includes safety checks
 */
function safeExecuteUpdatedRealisticFakeDataMigration() {
  // This is a development-only migration
  console.log('‚ö†Ô∏è  DEV MIGRATION: This is a development-only migration');
  console.log('Make sure you are working with a development/testing spreadsheet');

  const migration = new UpdatedRealisticFakeDataMigration(getSpreadsheetId());
  migration.execute();
}

/**
 * Main function to execute the realistic fake data migration
 */
function runUpdatedRealisticFakeDataMigration() {
  const migration = new UpdatedRealisticFakeDataMigration(getSpreadsheetId());
  migration.execute();
}

/**
 * Preview function to check what changes would be made
 * Run this first to see what the migration will do
 */
function previewUpdatedRealisticFakeDataMigration() {
  const migration = new UpdatedRealisticFakeDataMigration(getSpreadsheetId());
  migration.preview();
}

/**
 * Rollback function to restore original fake data
 * Use this if you need to revert to the original fake data patterns
 */
function rollbackUpdatedRealisticFakeDataMigration() {
  const migration = new UpdatedRealisticFakeDataMigration(getSpreadsheetId());
  migration.rollback();
}

/**
 * Updated Migration class for generating realistic fake data
 * Compatible with UUID structure and legacy ID preservation
 */
class UpdatedRealisticFakeDataMigration {
  constructor(spreadsheetId) {
    this.spreadsheet = SpreadsheetApp.openById(spreadsheetId);
    this.description =
      'Replace letter/number fake data with realistic fake names and maintain relational integrity (UUID compatible)';
    this.migrationId = 'Migration_DEV001_Updated_RealisticFakeData';

    // Track ID mappings for relational updates
    this.idMappings = {
      instructors: new Map(),
      parents: new Map(),
      students: new Map(),
      classes: new Map(),
      rooms: new Map()
    };

    // Realistic fake names database
    this.fakeNames = {
      instructors: [
        { firstName: 'Sarah', lastName: 'Johnson', email: 'sarah.johnson@tonic.edu' },
        { firstName: 'Michael', lastName: 'Chen', email: 'michael.chen@tonic.edu' },
        { firstName: 'Emma', lastName: 'Rodriguez', email: 'emma.rodriguez@tonic.edu' },
        { firstName: 'David', lastName: 'Thompson', email: 'david.thompson@tonic.edu' },
        { firstName: 'Jessica', lastName: 'Park', email: 'jessica.park@tonic.edu' },
        { firstName: 'Robert', lastName: 'Williams', email: 'robert.williams@tonic.edu' },
        { firstName: 'Ashley', lastName: 'Davis', email: 'ashley.davis@tonic.edu' },
        { firstName: 'James', lastName: 'Martinez', email: 'james.martinez@tonic.edu' },
        { firstName: 'Rachel', lastName: 'Anderson', email: 'rachel.anderson@tonic.edu' },
        { firstName: 'Christopher', lastName: 'Taylor', email: 'christopher.taylor@tonic.edu' },
        { firstName: 'Amanda', lastName: 'Brown', email: 'amanda.brown@tonic.edu' },
        { firstName: 'Daniel', lastName: 'Lee', email: 'daniel.lee@tonic.edu' },
        { firstName: 'Samantha', lastName: 'Wilson', email: 'samantha.wilson@tonic.edu' },
        { firstName: 'Andrew', lastName: 'Garcia', email: 'andrew.garcia@tonic.edu' },
        { firstName: 'Megan', lastName: 'Miller', email: 'megan.miller@tonic.edu' },
        { firstName: 'Kevin', lastName: 'Moore', email: 'kevin.moore@tonic.edu' },
        { firstName: 'Lauren', lastName: 'Jackson', email: 'lauren.jackson@tonic.edu' },
        { firstName: 'Ryan', lastName: 'White', email: 'ryan.white@tonic.edu' },
        { firstName: 'Nicole', lastName: 'Harris', email: 'nicole.harris@tonic.edu' },
        { firstName: 'Brandon', lastName: 'Clark', email: 'brandon.clark@tonic.edu' },
      ],
      parents: [
        { firstName: 'Jennifer', lastName: 'Adams' },
        { firstName: 'Mark', lastName: 'Campbell' },
        { firstName: 'Lisa', lastName: 'Parker' },
        { firstName: 'Steven', lastName: 'Evans' },
        { firstName: 'Michelle', lastName: 'Turner' },
        { firstName: 'Paul', lastName: 'Phillips' },
        { firstName: 'Karen', lastName: 'Mitchell' },
        { firstName: 'Brian', lastName: 'Carter' },
        { firstName: 'Susan', lastName: 'Roberts' },
        { firstName: 'John', lastName: 'Cook' },
        { firstName: 'Patricia', lastName: 'Bailey' },
        { firstName: 'William', lastName: 'Reed' },
        { firstName: 'Linda', lastName: 'Cooper' },
        { firstName: 'Richard', lastName: 'Richardson' },
        { firstName: 'Barbara', lastName: 'Cox' },
        { firstName: 'Joseph', lastName: 'Howard' },
        { firstName: 'Elizabeth', lastName: 'Ward' },
        { firstName: 'Thomas', lastName: 'Torres' },
        { firstName: 'Maria', lastName: 'Peterson' },
        { firstName: 'Charles', lastName: 'Gray' },
        { firstName: 'Nancy', lastName: 'Ramirez' },
        { firstName: 'Frank', lastName: 'James' },
        { firstName: 'Helen', lastName: 'Watson' },
        { firstName: 'George', lastName: 'Brooks' },
        { firstName: 'Sandra', lastName: 'Kelly' },
        { firstName: 'Kenneth', lastName: 'Sanders' },
        { firstName: 'Donna', lastName: 'Price' },
        { firstName: 'Anthony', lastName: 'Bennett' },
        { firstName: 'Carol', lastName: 'Wood' },
        { firstName: 'Edward', lastName: 'Barnes' },
        { firstName: 'Ruth', lastName: 'Ross' },
        { firstName: 'Jason', lastName: 'Henderson' },
        { firstName: 'Sharon', lastName: 'Coleman' },
        { firstName: 'Matthew', lastName: 'Jenkins' },
        { firstName: 'Betty', lastName: 'Perry' },
        { firstName: 'Gary', lastName: 'Powell' },
        { firstName: 'Deborah', lastName: 'Long' },
        { firstName: 'Ronald', lastName: 'Patterson' },
        { firstName: 'Angela', lastName: 'Hughes' },
        { firstName: 'Larry', lastName: 'Flores' },
      ],
      students: [
        { firstName: 'Alex', lastName: 'Johnson' },
        { firstName: 'Maya', lastName: 'Chen' },
        { firstName: 'Ethan', lastName: 'Rodriguez' },
        { firstName: 'Sophia', lastName: 'Thompson' },
        { firstName: 'Noah', lastName: 'Park' },
        { firstName: 'Isabella', lastName: 'Williams' },
        { firstName: 'Liam', lastName: 'Davis' },
        { firstName: 'Emma', lastName: 'Martinez' },
        { firstName: 'Oliver', lastName: 'Anderson' },
        { firstName: 'Ava', lastName: 'Taylor' },
        { firstName: 'William', lastName: 'Brown' },
        { firstName: 'Charlotte', lastName: 'Lee' },
        { firstName: 'James', lastName: 'Wilson' },
        { firstName: 'Amelia', lastName: 'Garcia' },
        { firstName: 'Benjamin', lastName: 'Miller' },
        { firstName: 'Harper', lastName: 'Moore' },
        { firstName: 'Lucas', lastName: 'Jackson' },
        { firstName: 'Evelyn', lastName: 'White' },
        { firstName: 'Henry', lastName: 'Harris' },
        { firstName: 'Abigail', lastName: 'Clark' },
        { firstName: 'Alexander', lastName: 'Lewis' },
        { firstName: 'Ella', lastName: 'Robinson' },
        { firstName: 'Jack', lastName: 'Walker' },
        { firstName: 'Grace', lastName: 'Young' },
        { firstName: 'Owen', lastName: 'Allen' },
        { firstName: 'Chloe', lastName: 'King' },
        { firstName: 'Luke', lastName: 'Wright' },
        { firstName: 'Zoey', lastName: 'Lopez' },
        { firstName: 'Sebastian', lastName: 'Hill' },
        { firstName: 'Lily', lastName: 'Scott' },
        { firstName: 'Mason', lastName: 'Green' },
        { firstName: 'Aria', lastName: 'Adams' },
        { firstName: 'Logan', lastName: 'Baker' },
        { firstName: 'Mia', lastName: 'Gonzalez' },
        { firstName: 'Carter', lastName: 'Nelson' },
        { firstName: 'Scarlett', lastName: 'Carter' },
        { firstName: 'Jacob', lastName: 'Mitchell' },
        { firstName: 'Madison', lastName: 'Perez' },
        { firstName: 'Jackson', lastName: 'Roberts' },
        { firstName: 'Layla', lastName: 'Turner' },
      ],
      roomNames: [
        'Piano Studio A', 'Piano Studio B', 'Voice Room 1', 'Voice Room 2', 
        'Guitar Room', 'Violin Studio', 'Ensemble Room', 'Practice Room 1',
        'Practice Room 2', 'Theory Classroom', 'Recording Studio', 'Percussion Room'
      ],
      classNames: [
        'Beginner Piano', 'Intermediate Piano', 'Advanced Piano', 'Piano Ensemble',
        'Voice Lessons', 'Guitar Fundamentals', 'Classical Guitar', 'Violin Basics',
        'String Ensemble', 'Music Theory', 'Composition', 'Jazz Piano',
        'Blues Guitar', 'Vocal Performance', 'Chamber Music'
      ]
    };
  }

  /**
   * Create backup before migration
   */
  createBackup() {
    try {
      const sheetsToBackup = ['instructors', 'parents', 'students', 'classes', 'rooms', 'registrations'];
      const backupResult = createMigrationBackup(this.migrationId, sheetsToBackup);
      console.log(`‚úÖ Backup created: ${backupResult.backupPrefix}`);
      return backupResult;
    } catch (error) {
      console.error('‚ö†Ô∏è  Backup creation failed:', error.message);
      console.log('Continuing with migration (backup recommended but not required)');
    }
  }

  /**
   * Execute the migration
   */
  execute() {
    console.log(`üöÄ Starting Migration: ${this.description}`);
    console.log(`üìã Migration ID: ${this.migrationId}`);
    
    console.log('‚ö†Ô∏è  DEV MIGRATION: This is a development-only migration');

    try {
      // Create backup
      this.createBackup();
      
      // Analyze current structure
      this.analyzeCurrentStructure();

      const results = {};

      console.log('\nüîÑ Updating data with realistic fake names...');

      // Update each table
      results.instructorsUpdated = this.updateInstructors();
      console.log(`   ‚úÖ Instructors: ${results.instructorsUpdated} records updated`);

      results.parentsUpdated = this.updateParents();
      console.log(`   ‚úÖ Parents: ${results.parentsUpdated} records updated`);

      results.studentsUpdated = this.updateStudents();
      console.log(`   ‚úÖ Students: ${results.studentsUpdated} records updated`);

      results.classesUpdated = this.updateClasses();
      console.log(`   ‚úÖ Classes: ${results.classesUpdated} records updated`);

      results.roomsUpdated = this.updateRooms();
      console.log(`   ‚úÖ Rooms: ${results.roomsUpdated} records updated`);

      // Update foreign key relationships
      results.relationshipsUpdated = this.updateRelationships();
      console.log(`   ‚úÖ Relationships: ${results.relationshipsUpdated} references updated`);

      console.log('\nüìä Migration completed successfully!');
      console.log(`   Total records updated: ${Object.values(results).reduce((a, b) => a + b, 0)}`);

    } catch (error) {
      console.error('‚ùå Migration failed:', error.message);
      console.log('üîÑ Consider restoring from backup if needed');
      throw error;
    }
  }

  /**
   * Preview the migration without making changes
   */
  preview() {
    console.log(`üîç Previewing Migration: ${this.description}`);
    console.log(`üìã Migration ID: ${this.migrationId}`);
    
    try {
      this.analyzeCurrentStructure();
      console.log('‚úÖ Preview completed - run execute() to apply changes');
    } catch (error) {
      console.error('‚ùå Preview failed:', error.message);
      throw error;
    }
  }

  /**
   * Analyze current structure and detect column patterns
   */
  analyzeCurrentStructure() {
    console.log('\nüîç Analyzing current sheet structures...');
    
    const sheets = ['instructors', 'parents', 'students', 'classes', 'rooms', 'registrations'];
    
    sheets.forEach(sheetName => {
      const sheet = this.spreadsheet.getSheetByName(sheetName);
      if (sheet) {
        const data = sheet.getDataRange().getValues();
        if (data.length > 0) {
          const headers = data[0];
          console.log(`   ${sheetName}: [${headers.slice(0, 6).join(', ')}${headers.length > 6 ? '...' : ''}]`);
          
          // Check for UUID vs legacy structure
          if (data.length > 1) {
            const firstRowId = data[1][0];
            const hasUUIDs = typeof firstRowId === 'string' && firstRowId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);
            const hasLegacyCol = headers.includes('LegacyId');
            console.log(`     - Structure: ${hasUUIDs ? 'UUID' : 'Legacy'} IDs, ${hasLegacyCol ? 'has' : 'no'} LegacyId column`);
          }
        }
      } else {
        console.log(`   ‚ö†Ô∏è  ${sheetName}: Sheet not found`);
      }
    });
  }

  /**
   * Find column index with flexible matching
   */
  findColumnIndex(headers, possibleNames) {
    for (const name of possibleNames) {
      const index = headers.findIndex(h => 
        h.toLowerCase().replace(/[^a-z]/g, '') === name.toLowerCase().replace(/[^a-z]/g, '')
      );
      if (index >= 0) return index;
    }
    return -1;
  }

  /**
   * Update instructors with realistic names
   */
  updateInstructors() {
    const sheet = this.spreadsheet.getSheetByName('instructors');
    if (!sheet) return 0;

    const data = sheet.getDataRange().getValues();
    if (data.length < 2) return 0;

    const headers = data[0];
    let updatedCount = 0;

    // Find column indices
    const idCol = this.findColumnIndex(headers, ['Id', 'id']);
    const legacyIdCol = this.findColumnIndex(headers, ['LegacyId', 'legacyid']);
    const emailCol = this.findColumnIndex(headers, ['Email', 'email']);
    const firstNameCol = this.findColumnIndex(headers, ['FirstName', 'firstname', 'first_name']);
    const lastNameCol = this.findColumnIndex(headers, ['LastName', 'lastname', 'last_name']);
    const phoneCol = this.findColumnIndex(headers, ['Phone', 'phone', 'phonenumber']);

    console.log(`   Instructor columns: Id=${idCol}, Email=${emailCol}, FirstName=${firstNameCol}, LastName=${lastNameCol}`);

    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const currentId = row[idCol];
      const currentEmail = emailCol >= 0 ? row[emailCol] : '';
      const currentFirstName = firstNameCol >= 0 ? row[firstNameCol] : '';
      
      // Check if this looks like fake data that needs updating
      const needsUpdate = this.isFakeInstructorData(currentId, currentEmail, currentFirstName);
      
      if (needsUpdate) {
        const instructorIndex = (i - 1) % this.fakeNames.instructors.length;
        const instructor = this.fakeNames.instructors[instructorIndex];

        // Store the old ID for relationship mapping
        this.idMappings.instructors.set(currentId, currentId); // Keep same ID, just update data

        // Update name fields
        if (firstNameCol >= 0) row[firstNameCol] = instructor.firstName;
        if (lastNameCol >= 0) row[lastNameCol] = instructor.lastName;
        if (emailCol >= 0) row[emailCol] = instructor.email;
        if (phoneCol >= 0) row[phoneCol] = this.generatePhoneNumber();

        // Update LegacyId if it exists and is fake data
        if (legacyIdCol >= 0) {
          const currentLegacyId = row[legacyIdCol];
          if (this.isFakeInstructorData(currentLegacyId, '', '')) {
            row[legacyIdCol] = instructor.email;
          }
        }

        updatedCount++;
      }
    }

    // Write back the updated data
    if (updatedCount > 0) {
      sheet.getDataRange().setValues(data);
    }

    return updatedCount;
  }

  /**
   * Update parents with realistic names
   */
  updateParents() {
    const sheet = this.spreadsheet.getSheetByName('parents');
    if (!sheet) return 0;

    const data = sheet.getDataRange().getValues();
    if (data.length < 2) return 0;

    const headers = data[0];
    let updatedCount = 0;

    // Find column indices (handle both "First Name" and "FirstName" formats)
    const idCol = this.findColumnIndex(headers, ['Id', 'id']);
    const legacyIdCol = this.findColumnIndex(headers, ['LegacyId', 'legacyid']);
    const emailCol = this.findColumnIndex(headers, ['Email', 'email']);
    const firstNameCol = this.findColumnIndex(headers, ['FirstName', 'firstname', 'first_name', 'First Name']);
    const lastNameCol = this.findColumnIndex(headers, ['LastName', 'lastname', 'last_name', 'Last Name']);
    const phoneCol = this.findColumnIndex(headers, ['Phone', 'phone', 'phonenumber']);

    console.log(`   Parent columns: Id=${idCol}, Email=${emailCol}, FirstName=${firstNameCol}, LastName=${lastNameCol}`);

    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const currentId = row[idCol];
      const currentEmail = emailCol >= 0 ? row[emailCol] : '';
      const currentFirstName = firstNameCol >= 0 ? row[firstNameCol] : '';
      
      // Check if this looks like fake data that needs updating
      const needsUpdate = this.isFakeParentData(currentId, currentEmail, currentFirstName);
      
      if (needsUpdate) {
        const parentIndex = (i - 1) % this.fakeNames.parents.length;
        const parent = this.fakeNames.parents[parentIndex];

        // Store the old ID for relationship mapping
        this.idMappings.parents.set(currentId, currentId); // Keep same ID, just update data

        // Generate email from name
        const email = `${parent.firstName.toLowerCase()}.${parent.lastName.toLowerCase()}@family.com`;

        // Update name fields
        if (firstNameCol >= 0) row[firstNameCol] = parent.firstName;
        if (lastNameCol >= 0) row[lastNameCol] = parent.lastName;
        if (emailCol >= 0) row[emailCol] = email;
        if (phoneCol >= 0) row[phoneCol] = this.generatePhoneNumber();

        // Update LegacyId if it exists and is fake data
        if (legacyIdCol >= 0) {
          const currentLegacyId = row[legacyIdCol];
          if (this.isFakeParentData(currentLegacyId, '', '')) {
            row[legacyIdCol] = `parent_email_${parent.firstName.toLowerCase()}_${parent.lastName.toLowerCase()}`;
          }
        }

        updatedCount++;
      }
    }

    // Write back the updated data
    if (updatedCount > 0) {
      sheet.getDataRange().setValues(data);
    }

    return updatedCount;
  }

  /**
   * Update students with realistic names
   */
  updateStudents() {
    const sheet = this.spreadsheet.getSheetByName('students');
    if (!sheet) return 0;

    const data = sheet.getDataRange().getValues();
    if (data.length < 2) return 0;

    const headers = data[0];
    let updatedCount = 0;

    // Find column indices
    const idCol = this.findColumnIndex(headers, ['Id', 'id']);
    const firstNameCol = this.findColumnIndex(headers, ['FirstName', 'firstname', 'first_name']);
    const lastNameCol = this.findColumnIndex(headers, ['LastName', 'lastname', 'last_name']);
    const nickFirstCol = this.findColumnIndex(headers, ['FirstNickname', 'firstnickname', 'first_nickname']);
    const nickLastCol = this.findColumnIndex(headers, ['LastNickname', 'lastnickname', 'last_nickname']);
    const gradeCol = this.findColumnIndex(headers, ['Grade', 'grade']);

    console.log(`   Student columns: Id=${idCol}, FirstName=${firstNameCol}, LastName=${lastNameCol}`);

    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const currentFirstName = firstNameCol >= 0 ? row[firstNameCol] : '';
      const currentLastName = lastNameCol >= 0 ? row[lastNameCol] : '';
      
      // Check if this looks like fake data that needs updating
      const needsUpdate = this.isFakeStudentData(currentFirstName, currentLastName);
      
      if (needsUpdate) {
        const studentIndex = (i - 1) % this.fakeNames.students.length;
        const student = this.fakeNames.students[studentIndex];

        // Update name fields
        if (firstNameCol >= 0) row[firstNameCol] = student.firstName;
        if (lastNameCol >= 0) row[lastNameCol] = student.lastName;
        if (nickFirstCol >= 0) row[nickFirstCol] = student.firstName;
        if (nickLastCol >= 0) row[nickLastCol] = student.lastName;
        
        // Assign realistic grades
        if (gradeCol >= 0) {
          const grades = ['K', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];
          row[gradeCol] = grades[Math.floor(Math.random() * grades.length)];
        }

        updatedCount++;
      }
    }

    // Write back the updated data
    if (updatedCount > 0) {
      sheet.getDataRange().setValues(data);
    }

    return updatedCount;
  }

  /**
   * Update classes with realistic names
   */
  updateClasses() {
    const sheet = this.spreadsheet.getSheetByName('classes');
    if (!sheet) return 0;

    const data = sheet.getDataRange().getValues();
    if (data.length < 2) return 0;

    const headers = data[0];
    let updatedCount = 0;

    // Find column indices
    const idCol = this.findColumnIndex(headers, ['Id', 'id']);
    const nameCol = this.findColumnIndex(headers, ['Name', 'name', 'ClassName', 'classname', 'class_name']);
    const instrumentCol = this.findColumnIndex(headers, ['Instrument', 'instrument']);

    console.log(`   Class columns: Id=${idCol}, Name=${nameCol}, Instrument=${instrumentCol}`);

    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const currentName = nameCol >= 0 ? row[nameCol] : '';
      
      // Check if this looks like fake data that needs updating
      const needsUpdate = this.isFakeClassData(currentName);
      
      if (needsUpdate) {
        const classIndex = (i - 1) % this.fakeNames.classNames.length;
        const className = this.fakeNames.classNames[classIndex];

        // Update class name
        if (nameCol >= 0) row[nameCol] = className;
        
        // Set instrument based on class name
        if (instrumentCol >= 0) {
          row[instrumentCol] = this.getInstrumentFromClassName(className);
        }

        updatedCount++;
      }
    }

    // Write back the updated data
    if (updatedCount > 0) {
      sheet.getDataRange().setValues(data);
    }

    return updatedCount;
  }

  /**
   * Update rooms with realistic names
   */
  updateRooms() {
    const sheet = this.spreadsheet.getSheetByName('rooms');
    if (!sheet) return 0;

    const data = sheet.getDataRange().getValues();
    if (data.length < 2) return 0;

    const headers = data[0];
    let updatedCount = 0;

    // Find column indices
    const idCol = this.findColumnIndex(headers, ['Id', 'id']);
    const nameCol = this.findColumnIndex(headers, ['Name', 'name', 'RoomName', 'roomname', 'room_name']);

    console.log(`   Room columns: Id=${idCol}, Name=${nameCol}`);

    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const currentName = nameCol >= 0 ? row[nameCol] : '';
      
      // Check if this looks like fake data that needs updating
      const needsUpdate = this.isFakeRoomData(currentName);
      
      if (needsUpdate) {
        const roomIndex = (i - 1) % this.fakeNames.roomNames.length;
        const roomName = this.fakeNames.roomNames[roomIndex];

        // Update room name
        if (nameCol >= 0) row[nameCol] = roomName;

        updatedCount++;
      }
    }

    // Write back the updated data
    if (updatedCount > 0) {
      sheet.getDataRange().setValues(data);
    }

    return updatedCount;
  }

  /**
   * Update foreign key relationships (not needed if we keep same IDs)
   */
  updateRelationships() {
    // Since we're keeping the same IDs and just updating the data,
    // we don't need to update foreign key relationships
    console.log('   Foreign key relationships preserved (IDs unchanged)');
    return 0;
  }

  /**
   * Check if instructor data looks fake
   */
  isFakeInstructorData(id, email, firstName) {
    const fakePatterns = [
      'TEACHER', 'Teacher', 'instructor', 'Instructor',
      '@EMAIL.COM', 'test@', 'fake@'
    ];
    const text = `${id} ${email} ${firstName}`.toLowerCase();
    return fakePatterns.some(pattern => text.includes(pattern.toLowerCase()));
  }

  /**
   * Check if parent data looks fake
   */
  isFakeParentData(id, email, firstName) {
    const fakePatterns = [
      'parent', 'Parent', 'PARENT', 'parent_email',
      'test@', 'fake@', '@EMAIL.COM'
    ];
    const text = `${id} ${email} ${firstName}`.toLowerCase();
    return fakePatterns.some(pattern => text.includes(pattern.toLowerCase()));
  }

  /**
   * Check if student data looks fake
   */
  isFakeStudentData(firstName, lastName) {
    const fakePatterns = [
      'A4', 'B1', 'K4-1', 'Student', 'STUDENT', 'Child'
    ];
    const text = `${firstName} ${lastName}`.toLowerCase();
    return fakePatterns.some(pattern => text.includes(pattern.toLowerCase()));
  }

  /**
   * Check if class data looks fake
   */
  isFakeClassData(name) {
    const fakePatterns = [
      'Class', 'GROUP', 'Group', 'TEST', 'Test'
    ];
    const text = `${name}`.toLowerCase();
    return fakePatterns.some(pattern => text.includes(pattern.toLowerCase()));
  }

  /**
   * Check if room data looks fake
   */
  isFakeRoomData(name) {
    const fakePatterns = [
      'Room', 'ROOM', 'TEST', 'Test'
    ];
    const text = `${name}`.toLowerCase();
    return fakePatterns.some(pattern => text.includes(pattern.toLowerCase()));
  }

  /**
   * Get instrument from class name
   */
  getInstrumentFromClassName(className) {
    const name = className.toLowerCase();
    if (name.includes('piano')) return 'Piano';
    if (name.includes('guitar')) return 'Guitar';
    if (name.includes('voice') || name.includes('vocal')) return 'Voice';
    if (name.includes('violin')) return 'Violin';
    if (name.includes('drum') || name.includes('percussion')) return 'Drums';
    if (name.includes('theory') || name.includes('composition')) return 'Theory';
    return 'Piano'; // Default
  }

  /**
   * Generate a realistic phone number
   */
  generatePhoneNumber() {
    const area = Math.floor(Math.random() * 800) + 200;
    const exchange = Math.floor(Math.random() * 800) + 200;
    const number = Math.floor(Math.random() * 9000) + 1000;
    return `(${area}) ${exchange}-${number}`;
  }

  /**
   * Rollback the migration by restoring from backup
   */
  rollback() {
    console.log(`üîÑ Rolling back migration: ${this.migrationId}`);
    try {
      const result = restoreFromBackup(this.migrationId);
      if (result.success) {
        console.log('‚úÖ Rollback completed successfully');
      } else {
        console.log('‚ùå Rollback failed:', result.error);
      }
      return result;
    } catch (error) {
      console.error('‚ùå Rollback error:', error.message);
      return { success: false, error: error.message };
    }
  }
}

/**
 * Rollback function for this migration
 */
function rollbackUpdatedRealisticFakeDataMigration() {
  const migration = new UpdatedRealisticFakeDataMigration(getSpreadsheetId());
  return migration.rollback();
}
