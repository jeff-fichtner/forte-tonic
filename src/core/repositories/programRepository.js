class ProgramRepository {

  constructor(dbClient) {
    this.dbClient = dbClient;
  }

  getClasses(forceRefresh = false) {
    return RepositoryHelper.getAndSetData(
      () => this.classes,
      () => this.classes =
        this.dbClient.getAllRecords(
          Keys.CLASSES,
          x => new Class(...x)),
      Keys.CLASSES,
      forceRefresh);
  }

  getClassById(id) {
    return this.getClasses().find(x => x.Id === id);
  }

  getRegistrations(forceRefresh = false) {
    return RepositoryHelper.getAndSetData(
      () => this.registrations,
      () => this.registrations =
        this.dbClient.getAllRecords(
          Keys.REGISTRATIONS,
          x => {
            const newRegistration = new Registration(...x);
            newRegistration.startTime = DateHelpers.parseGoogleSheetsDate(newRegistration.startTime);
            return newRegistration;
          }),
      Keys.REGISTRATIONS,
      forceRefresh);
  }

  getRegistrationById(id) {
    return this.getRegistrations().find(x => x.id === id);
  }

  register(registrationData, instructor, createdBy) {
    // TODO data validation
    registrationData.registrationType = RegistrationType.PRIVATE;
    const date = DateHelpers.getStartOfCurrentDayUTC();

    const rooms = [
      instructor.mondayRoomId,
      instructor.tuesdayRoomId,
      instructor.wednesdayRoomId,
      instructor.thursdayRoomId,
      instructor.fridayRoomId
    ];

    registrationData.roomId = rooms[registrationData.day * 1];

    registrationData.expectedStartDate = date;

    const weekDays = [
      'Monday',
      'Tuesday',
      'Wednesday',
      'Thursday',
      'Friday'
    ]

    const record =
      new Registration(
        0, // id will be generated by the database
        registrationData.studentId,
        registrationData.instructorId,
        weekDays[registrationData.day * 1],
        registrationData.startTime,
        registrationData.length,
        registrationData.registrationType,
        registrationData.roomId,
        registrationData.instrument,
        registrationData.transportationType,
        registrationData.notes,
        registrationData.expectedStartDate,
      );

    return this.dbClient.appendRecord(Keys.REGISTRATIONS, record, createdBy);
  }

  getAttendanceForRegistrations(registrationIds) {
    const records = RepositoryHelper.getAndSetData(
      () => this.attendanceRecords,
      () => this.attendanceRecords =
        this.dbClient.getAllRecords(
          Keys.ATTENDANCE,
          x => new AttendanceRecord(...x)),
      Keys.ATTENDANCE);

    return records.filter(x => registrationIds.includes(x.registrationId));
  }

  unregister(registrationId, deletedBy) {
    try {
      this.dbClient.deleteRecord(Keys.REGISTRATIONS, registrationId, deletedBy);
      return true;
    } catch (error) {
      console.error(`Failed to unregister registration with ID ${registrationId}:`, error);
      return false;
    }
  }

  recordAttendance(registrationId, createdBy) {
    const attendanceRecords = this.getAttendanceForRegistrations([registrationId]);
    if (attendanceRecords.length > 0) {
      console.warn(`Attendance already recorded for registration ID ${registrationId}`);
      return attendanceRecords[0];
    }

    return this.dbClient.appendRecord(Keys.ATTENDANCE, new AttendanceRecord(registrationId), createdBy);
  }

  removeAttendance(registrationId, deletedBy) {
    const attendanceRecords = this.getAttendanceForRegistrations([registrationId]);
    if (attendanceRecords.length === 0) {
      console.warn(`No attendance record found for registration ID ${registrationId}`);
      return true;
    }

    this.dbClient.deleteRecord(Keys.ATTENDANCE, registrationId, deletedBy);
  }
}
