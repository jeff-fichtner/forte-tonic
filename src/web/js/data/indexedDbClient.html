<script>
    class IndexedDbClient {
        constructor(dbName, storeNames) {
            this.dbName = dbName;
            this.storeNames = storeNames;
        }

        // Initialize the database
        async init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(this.dbName, 1);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    this.storeNames.forEach(storeName => {
                        if (!db.objectStoreNames.contains(storeName)) {
                            db.createObjectStore(storeName, { keyPath: 'db_id', autoIncrement: true });
                        }
                    });
                };

                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    resolve();
                };

                request.onerror = (event) => {
                    reject(`Database error: ${event.target.errorCode}`);
                };
            });
        }

        async count(storeName) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);

                const request = store.count();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(`Count error: ${event.target.errorCode}`);
            });
        }

        async getAll(storeName, mapFunction = null) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);

                const request = store.getAll();
                request.onsuccess = () => {
                    resolve(
                        mapFunction
                            ? request.result.map(mapFunction)
                            : request.result);
                };
                request.onerror = (event) => reject(`Get all error: ${event.target.errorCode}`);
            });
        }

        async hasItems(storeName) {
            try {
                const count = await this.count(storeName);
                return count > 0;
            } catch (error) {
                console.error(`Error checking items in ${storeName}:`, error);
                return false;
            }
        }

        async insertRange(storeName, items) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);

                items.forEach(item => {
                    store.add(item);
                });

                transaction.oncomplete = () => resolve();
                transaction.onerror = (event) => reject(`Transaction error: ${event.target.errorCode}`);
            });
        }

        async clear(storeName) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);

                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(`Clear error: ${event.target.errorCode}`);
            });
        }
    }
</script>